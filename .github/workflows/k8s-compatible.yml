name: Kubernetes Compatible

on:
  pull_request:
    branches:
      - main
  workflow_dispatch:

jobs:
  check-compatible:
    strategy:
      matrix:
        node-image:
          - kindest/node:v1.30.13@sha256:397209b3d947d154f6641f2d0ce8d473732bd91c87d9575ade99049aa33cd648
          - kindest/node:v1.31.12@sha256:0f5cc49c5e73c0c2bb6e2df56e7df189240d83cf94edfa30946482eb08ec57d2
          - kindest/node:v1.32.8@sha256:abd489f042d2b644e2d033f5c2d900bc707798d075e8186cb65e3f1367a9d5a1
          - kindest/node:v1.33.4@sha256:25a6018e48dfcaee478f4a59af81157a437f15e6e140bf103f85a2e7cd0cbbf2
          - kindest/node:v1.34.0@sha256:7416a61b42b1662ca6ca89f02028ac133a309a2a30ba309614e8ec94d976dc5a
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache-dependency-path: go.sum

      - name: Create kind cluster
        id: kind
        uses: helm/kind-action@v1
        with:
          node_image: ${{ matrix.node-image }}
          registry: true
          registry_name: my-registry
          registry_port: 5001
          registry_enable_delete: true

      - name: Verify kind installation
        run: |
          kubectl cluster-info

      - name: Build webhook
        id: build
        run: |
          IMAGE_TAG=$(openssl rand -hex 4)
          IMAGE_REPOSITORY=${{ steps.kind.outputs.LOCAL_REGISTRY }}/alidns-webhook
          IMAGE_NAME=$IMAGE_REPOSITORY IMAGE_TAG=$IMAGE_TAG make build
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "IMAGE_REPOSITORY=$IMAGE_REPOSITORY" >> $GITHUB_OUTPUT

      - name: Install helm
        run: |
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

      - name: Verify helm installation
        run: |
          helm version

      - name: Install cert-manager
        run: |
          helm upgrade cert-manager cert-manager --install \
            --repo https://charts.jetstack.io \
            --set crds.enabled=true \
            --namespace cert-manager --create-namespace

      - name: Wait for cert-manager to be ready
        run: |
          kubectl wait --namespace cert-manager --for=condition=available --timeout=300s deployment/cert-manager
          kubectl wait --namespace cert-manager --for=condition=available --timeout=300s deployment/cert-manager-webhook
          kubectl wait --namespace cert-manager --for=condition=available --timeout=300s deployment/cert-manager-cainjector

      - name: Install webhook
        run: |
          helm upgrade --install alidns-webhook alidns-webhook \
            --repo https://wjiec.github.io/alidns-webhook \
            --namespace cert-manager --create-namespace \
            --set groupName=acme.yourcompany.com \
            --set image.repository=${{ steps.build.outputs.IMAGE_REPOSITORY }} \
            --set image.tag=${{ steps.build.outputs.IMAGE_TAG }}

      - name: Wait for webhook to be ready
        run: |
          kubectl wait --namespace cert-manager --for=condition=available --timeout=300s deployment/alidns-webhook

      - name: Create ClusterIssuer
        id: cluster-issuer
        env:
          WEBHOOK_ACCESS_KEY_ID: ${{ secrets.WEBHOOK_ACCESS_KEY_ID }}
          WEBHOOK_ACCESS_KEY_SECRET: ${{ secrets.WEBHOOK_ACCESS_KEY_SECRET }}
        run: |
          kubectl apply -f - <<EOF
          apiVersion: v1
          kind: Secret
          metadata:
            name: alidns-secret
            namespace: cert-manager
          stringData:
            access-key-id: "${WEBHOOK_ACCESS_KEY_ID}"
            access-key-secret: "${WEBHOOK_ACCESS_KEY_SECRET}"
          ---
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: example-acme
          spec:
            acme:
              server: https://acme-staging-v02.api.letsencrypt.org/directory
              privateKeySecretRef:
                name: example-acme
              solvers:
                - dns01:
                    webhook:
                      groupName: acme.yourcompany.com
                      solverName: alidns
                      config:
                        accessKeyIdRef:
                          name: alidns-secret
                          key: access-key-id
                        accessKeySecretRef:
                          name: alidns-secret
                          key: access-key-secret
          EOF

      - name: Wait for ClusterIssuer to be ready
        run: |
          kubectl wait --for=condition=ready --timeout=300s clusterissuer/example-acme

      - name: Create certificate
        env:
          WEBHOOK_DOMAIN_NAME: ${{ secrets.WEBHOOK_DOMAIN_NAME }}
        run: |
          RANDOM_SUB_DOMAIN=$(openssl rand -hex 6)
          kubectl apply -f - <<EOF
          apiVersion: cert-manager.io/v1
          kind: Certificate
          metadata:
            name: random-cert
          spec:
            secretName: random-tls
            commonName: "${RANDOM_SUB_DOMAIN}.${WEBHOOK_DOMAIN_NAME}"
            dnsNames:
              - "${RANDOM_SUB_DOMAIN}.${WEBHOOK_DOMAIN_NAME}"
            issuerRef:
              name: example-acme
              kind: ClusterIssuer
          EOF

      - name: Wait for certificate to be ready
        run: |
          kubectl wait --for=condition=ready --timeout=650s certificate/random-cert

  compatible-ok:
    if: always()
    needs: check-compatible
    runs-on: ubuntu-latest

    steps:
      - name: Report job result
        env:
          COMPATIBLE_BUILD_RESULT: ${{ needs.check-compatible.result }}
        run: |
          if [[ $COMPATIBLE_BUILD_RESULT == "success" ]]; then exit 0; fi
          exit 1
